---
layout: page
title: "Series"
description: "All posts that are part of a series"
hasComments: 0
date: 2020-01-01
---

Many of the posts on this site are part of an in-depth look at one aspect of functional programming or F#. If you like deep dives, then here they all are in one place!

* [**Why use F#?**](/series/why-use-fsharp/)\
  This series of posts will give you a guided tour through the main features of F# and then show you ways that F# can help you in your day-to-day development.
* [**Thinking functionally**](/series/thinking-functionally/)\
  This series of posts will introduce you to the fundamentals of functional  programming â€“ what does it really mean to "program functionally", and how this approach differs from object oriented or imperative programming.
* [**Understanding F# types**](/series/understanding-fsharp-types/)\
  F# is not just about functions; the powerful type system is another key ingredient.  And just as with functions, understanding the type system is critical to being fluent and comfortable in the language.
* [**Expressions and syntax**](/series/expressions-and-syntax/)\
  In this series of posts we'll look at how functions and values are combined into expressions, and the different kinds of expressions that are available in F#.
* [**Object-oriented programming in F#**](/series/object-oriented-programming-in-fsharp/)\
  F# is fundamentally a functional language at heart, yet the OO features have been nicely integrated and do not have a "tacked-on" feeling. As a result, it is quite viable to use F# just as an OO language, as an alternative to C#, say.
* [**Computation expressions**](/series/computation-expressions/)\
  In this series, you'll learn what computation expressions are, some common patterns, and how to make your own. In the process, we'll also look at continuations, the bind function, wrapper types, and more.
* [**Designing with types**](/series/designing-with-types/)\
  In this series, we'll look at some of the ways we can use types as part of the design process. In particular, the thoughtful use of types can make a design more transparent and improve correctness at the same time.
* [**Map and Bind and Apply, Oh my!**](/series/map-and-bind-and-apply-oh-my/)\
  In this series of posts, I'll attempt to describe some of the core functions for dealing with generic data types (such as `Option` and `List`). In other words, a sort of "man page" for `map`, `return`, `apply`, and `bind`.
* [**Property Based Testing**](/series/property-based-testing/)\
  This series of posts will introduce you to the fundamentals of property-based testing: how it is different from traditional example-based testing, why it is important, and how to work with properties in theory and practice.
* [**The Return of the EDFH**](/series/return-of-the-edfh/)\
  A follow-up to [my previous series on property-based testing](/series/property-based-testing) and the Enterprise Developer From Hell. It revisits the fundamentals of property-based testing and how to use the EDFH to help design useful and effective tests.
* [**Recursive types and folds**](/series/recursive-types-and-folds/)\
  In this series, we'll look at recursive types and how to use them, and on the way, we'll look at catamorphisms, tail recursion, the difference between left and right folds, and more.
* [**Understanding monoids**](/series/understanding-monoids/)\
  In this series, we'll look at a very common "pattern" known as a *monoid*. Monoids are not really a design pattern; more an approach to working with many different types of values in a common way. In fact, once you understand monoids, you will start seeing them everywhere!
* [**Understanding Parser Combinators**](/series/understanding-parser-combinators/)\
  In this series, we'll look at how so-called "applicative parsers" work. In order to understand something, there's nothing like building it for yourself, and so we'll create a basic parser library from scratch, then some useful "parser combinators", and then finish off by building a complete JSON parser.
* [**Handling State with the Monadster**](/series/handling-state)\
  In this series of posts, I'll look at how you can thread state through a series of pure functions in a convenient way using the state monad.
* [**Dependency cycles**](/series/dependency-cycles/)\
  One of the most common complaints about F# is that it requires code to be in *dependency order*. That is, you cannot use forward references to code that hasn't been seen by the compiler yet. In this series, I discuss dependency cycles, why they are bad, and how to get rid of them.
* [**A functional approach to authorization**](/series/a-functional-approach-to-authorization/)\
  In this series of posts, I'll look at how you might handle the common security challenge of authorization. That is, how can you ensure that clients of your code can only do what you want them to do? This series will sketch out two different approaches, first using an approach called *capability based security*, and second using statically checked types to emulate access tokens.
* [**Low-risk ways to use F# at work**](/series/low-risk-ways-to-use-fsharp-at-work)\
  This series will suggest a number of ways you can get your hands dirty with F# in a low-risk, incremental way, without affecting any mission critical code.



